اگر از JWT استفاده نمی‌کنید و تنها می‌خواهید با استفاده از نقش‌های Identity کنترل دسترسی به اکشن‌های کنترلر UserController را مدیریت کنید، تنظیماتی که در پیشنهاد قبلی آوردم را انجام دهید. به عبارت دقیق‌تر، از تنظیمات Identity و مجوز دهی به صورت زیر استفاده کنید:

ابتدا در فایل Startup.cs، متد ConfigureServices را به شکل زیر تنظیم کنید:
csharp
Copy code
public void ConfigureServices(IServiceCollection services)
{
    // ...

    // افزودن سیستم احراز هویت
    services.AddAuthentication(options =>
    {
        options.DefaultAuthenticateScheme = IdentityConstants.ApplicationScheme;
        options.DefaultChallengeScheme = IdentityConstants.ApplicationScheme;
    });

    // افزودن سیستم مجوز دهی
    services.AddAuthorization(options =>
    {
        options.AddPolicy("UserPolicy", policy =>
        {
            policy.RequireAuthenticatedUser();
            policy.RequireRole("User");
        });
    });

    // ...
}
در متد Configure فایل Startup.cs، از کد زیر برای اعمال سیاست مجوز "UserPolicy" برای کل کنترلر UserController استفاده کنید:
csharp
Copy code
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    // ...

    app.UseRouting();

    // اعمال میان‌افزار احراز هویت و مجوز دهی
    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers().RequireAuthorization("UserPolicy");
    });

    // ...
}
با این تنظیمات، تنها کاربرانی که وارد شده‌اند و نقش "User" را دارند، به اکشن‌های کنترلر UserController دسترسی دارند. در غیر اینصورت، دسترسی به این اکشن‌ها به صورت اتوماتیک محدود خواهد شد و نیازی به JWT یا مکانیزم‌های دیگر نیست.






 مشکل این است که x.City_Tbls مقدار null را برمی‌گرداند و به خطا می‌خورید، باید ابتدا اطمینان حاصل کنید که این خصوصیت به درستی بارگذاری شده باشد. به نظر می‌رسد که این خصوصیت به صورت تاخیری (lazy-loading) بارگذاری می‌شود و اگر اطمینان حاصل نشود که مقداری دارد، خطا به وجود می‌آید.

برای حل این مشکل می‌توانید از یکی از روش‌های زیر استفاده کنید:

Eager Loading: در ابتدا اطمینان حاصل کنید که City_Tbls به صورت eagerly (فوراً) بارگذاری شده باشد. برای این کار می‌توانید از روش Include در Entity Framework استفاده کنید. مثال:
csharp
Copy code
var Query = khanehBehdashtRepository.GetAll()
    .Include(x => x.City_Tbls)
    .Where(x => x.Markaz_ID == this.Markaz_ID);
Null Check: قبل از دسترسی به x.City_Tbls اطمینان حاصل کنید که مقدار آن null نیست. مثال:
csharp
Copy code
Rosta_Count = x.City_Tbls != null ? x.City_Tbls.Count() : 0
همچنین توجه داشته باشید که در مورد استفاده از eager loading، باید مطمئن شوید که مربوط به کد اصلی شما استفاده می‌شود و تأثیرات جانبی در دیگر قسمت‌های برنامه ایجاد نمی‌شود.




User
اگه این کد رو بزارم 
var Query = khanehBehdashtRepository.GetAll()
    .Include(x => x.City_Tbls)
    .Where(x => x.Markaz_ID == this.Markaz_ID);
دیگه از این query ها نمیتونم استفاده کنم 
 var Query = khanehBehdashtRepository.GetAll().Where(x => x.Markaz_ID == this.Markaz_ID);
ChatGPT
در صورتی که از Eager Loading استفاده کنید و با Include داده‌های مرتبط را بارگذاری کنید، به صورت پیش‌فرض داده‌های مرتبط در همان زمان بارگذاری می‌شوند و شما می‌توانید از آن‌ها در ادامه کار استفاده کنید. این به شما این امکان را می‌دهد که در یک کوئری مشترک از داده‌های اصلی و مرتبط استفاده کنید.

پس اگر Query را به صورت زیر تعریف کنید:

csharp
Copy code
var Query = khanehBehdashtRepository.GetAll()
    .Include(x => x.City_Tbls)
    .Where(x => x.Markaz_ID == this.Markaz_ID);
سپس می‌توانید از آن در ادامه کار استفاده کنید بدون نیاز به تعریف مجدد Query:

csharp
Copy code
var results = Query.ToList(); // یا هر عملیات دیگری که می‌خواهید روی این کوئری انجام دهید
بدین ترتیب، شما داده‌های مرتبط را همزمان با داده‌های اصلی بارگذاری می‌کنید و می‌توانید در کلیه کوئری‌های بعدی از آن استفاده کنید.


 //modelBuilder.Entity<ApplicationUser>().HasKey(u => u.Id);
            //modelBuilder.Entity<ApplicationRole>().HasKey(r => r.Id);
            //modelBuilder.Entity<IdentityUserRole<Guid>>().HasKey(r => new { r.UserId, r.RoleId });
            //modelBuilder.Entity<IdentityUserLogin<Guid>>().HasNoKey();
            //modelBuilder.Entity<IdentityUserToken<Guid>>().HasKey(t=> new {t.UserId,t.LoginProvider,t.Name});
            //modelBuilder.Entity<IdentityRole<Guid>>().HasData(
            //new IdentityRole<Guid>
            //{
            //        Id = Guid.NewGuid(),
            //        Name = "Admin",
            //        NormalizedName = "Admin".ToUpper()
            //    },
            //new IdentityRole<Guid>
            //{
            //    Id = Guid.NewGuid(),
            //    Name = "User",
            //    NormalizedName = "User".ToUpper()
            //}
            //);
            //modelBuilder.Entity<ApplicationUser>().ToTable("AspNetUsers"); 
            //modelBuilder.Entity<User>().ToTable("Users");
            //modelBuilder.Entity<ApplicationUser>()
            //  .HasOne(u => u.Users)
            //   .WithOne(user => user.ApplicationUser)
            //   .HasForeignKey<User>(user => user.ApplicationUserId);
            //modelBuilder.Entity<ApplicationUser>().ToTable("AspNetUsers"); // نام جدول مرتبط با ApplicationUser را تغییر می‌دهیم
            //modelBuilder.Entity<User>().ToTable("Users"); // نام جدول مرتبط با User را تغییر می‌دهیم

            //// تعریف رابطه بین ApplicationUser و User
            //modelBuilder.Entity<ApplicationUser>()
            //    .HasOne(u => u.User)
            //    .WithOne(user => user.ApplicationUser)
            //    .HasForeignKey<User>(user => user.ApplicationUserId);
            //The entity type 'IdentityUserToken<Guid>' requires a primary key to be defined.If you intended to use a keyless entity type, call 'HasNoKey' in 'OnModelCreating'.For more information on keyless entity types, see https://go.microsoft.com/fwlink/?linkid=2141943.




            var Applicationuser  = new ApplicationUser
                {
                    UserName = this.User_Code,
                    Users = new AuthTestUser.Entities.User()
                    {
                        User_ID = this.User_ID,
                        User_Code = this.User_Code,
                        User_Pass = this.User_Pass,
                        User_FullName = this.User_FullName,
                        User_Role = this.User_Role
                    }

                };
                var result =  _userManager.CreateAsync(Applicationuser, this.User_Pass);
                _userManager.AddToRoleAsync(Applicationuser, this.User_Role);
