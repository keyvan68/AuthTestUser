اگر از JWT استفاده نمی‌کنید و تنها می‌خواهید با استفاده از نقش‌های Identity کنترل دسترسی به اکشن‌های کنترلر UserController را مدیریت کنید، تنظیماتی که در پیشنهاد قبلی آوردم را انجام دهید. به عبارت دقیق‌تر، از تنظیمات Identity و مجوز دهی به صورت زیر استفاده کنید:

ابتدا در فایل Startup.cs، متد ConfigureServices را به شکل زیر تنظیم کنید:
csharp
Copy code
public void ConfigureServices(IServiceCollection services)
{
    // ...

    // افزودن سیستم احراز هویت
    services.AddAuthentication(options =>
    {
        options.DefaultAuthenticateScheme = IdentityConstants.ApplicationScheme;
        options.DefaultChallengeScheme = IdentityConstants.ApplicationScheme;
    });

    // افزودن سیستم مجوز دهی
    services.AddAuthorization(options =>
    {
        options.AddPolicy("UserPolicy", policy =>
        {
            policy.RequireAuthenticatedUser();
            policy.RequireRole("User");
        });
    });

    // ...
}
در متد Configure فایل Startup.cs، از کد زیر برای اعمال سیاست مجوز "UserPolicy" برای کل کنترلر UserController استفاده کنید:
csharp
Copy code
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    // ...

    app.UseRouting();

    // اعمال میان‌افزار احراز هویت و مجوز دهی
    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers().RequireAuthorization("UserPolicy");
    });

    // ...
}
با این تنظیمات، تنها کاربرانی که وارد شده‌اند و نقش "User" را دارند، به اکشن‌های کنترلر UserController دسترسی دارند. در غیر اینصورت، دسترسی به این اکشن‌ها به صورت اتوماتیک محدود خواهد شد و نیازی به JWT یا مکانیزم‌های دیگر نیست.






 مشکل این است که x.City_Tbls مقدار null را برمی‌گرداند و به خطا می‌خورید، باید ابتدا اطمینان حاصل کنید که این خصوصیت به درستی بارگذاری شده باشد. به نظر می‌رسد که این خصوصیت به صورت تاخیری (lazy-loading) بارگذاری می‌شود و اگر اطمینان حاصل نشود که مقداری دارد، خطا به وجود می‌آید.

برای حل این مشکل می‌توانید از یکی از روش‌های زیر استفاده کنید:

Eager Loading: در ابتدا اطمینان حاصل کنید که City_Tbls به صورت eagerly (فوراً) بارگذاری شده باشد. برای این کار می‌توانید از روش Include در Entity Framework استفاده کنید. مثال:
csharp
Copy code
var Query = khanehBehdashtRepository.GetAll()
    .Include(x => x.City_Tbls)
    .Where(x => x.Markaz_ID == this.Markaz_ID);
Null Check: قبل از دسترسی به x.City_Tbls اطمینان حاصل کنید که مقدار آن null نیست. مثال:
csharp
Copy code
Rosta_Count = x.City_Tbls != null ? x.City_Tbls.Count() : 0
همچنین توجه داشته باشید که در مورد استفاده از eager loading، باید مطمئن شوید که مربوط به کد اصلی شما استفاده می‌شود و تأثیرات جانبی در دیگر قسمت‌های برنامه ایجاد نمی‌شود.




User
اگه این کد رو بزارم 
var Query = khanehBehdashtRepository.GetAll()
    .Include(x => x.City_Tbls)
    .Where(x => x.Markaz_ID == this.Markaz_ID);
دیگه از این query ها نمیتونم استفاده کنم 
 var Query = khanehBehdashtRepository.GetAll().Where(x => x.Markaz_ID == this.Markaz_ID);
ChatGPT
در صورتی که از Eager Loading استفاده کنید و با Include داده‌های مرتبط را بارگذاری کنید، به صورت پیش‌فرض داده‌های مرتبط در همان زمان بارگذاری می‌شوند و شما می‌توانید از آن‌ها در ادامه کار استفاده کنید. این به شما این امکان را می‌دهد که در یک کوئری مشترک از داده‌های اصلی و مرتبط استفاده کنید.

پس اگر Query را به صورت زیر تعریف کنید:

csharp
Copy code
var Query = khanehBehdashtRepository.GetAll()
    .Include(x => x.City_Tbls)
    .Where(x => x.Markaz_ID == this.Markaz_ID);
سپس می‌توانید از آن در ادامه کار استفاده کنید بدون نیاز به تعریف مجدد Query:

csharp
Copy code
var results = Query.ToList(); // یا هر عملیات دیگری که می‌خواهید روی این کوئری انجام دهید
بدین ترتیب، شما داده‌های مرتبط را همزمان با داده‌های اصلی بارگذاری می‌کنید و می‌توانید در کلیه کوئری‌های بعدی از آن استفاده کنید.


 //modelBuilder.Entity<ApplicationUser>().HasKey(u => u.Id);
            //modelBuilder.Entity<ApplicationRole>().HasKey(r => r.Id);
            //modelBuilder.Entity<IdentityUserRole<Guid>>().HasKey(r => new { r.UserId, r.RoleId });
            //modelBuilder.Entity<IdentityUserLogin<Guid>>().HasNoKey();
            //modelBuilder.Entity<IdentityUserToken<Guid>>().HasKey(t=> new {t.UserId,t.LoginProvider,t.Name});
            //modelBuilder.Entity<IdentityRole<Guid>>().HasData(
            //new IdentityRole<Guid>
            //{
            //        Id = Guid.NewGuid(),
            //        Name = "Admin",
            //        NormalizedName = "Admin".ToUpper()
            //    },
            //new IdentityRole<Guid>
            //{
            //    Id = Guid.NewGuid(),
            //    Name = "User",
            //    NormalizedName = "User".ToUpper()
            //}
            //);
            //modelBuilder.Entity<ApplicationUser>().ToTable("AspNetUsers"); 
            //modelBuilder.Entity<User>().ToTable("Users");
            //modelBuilder.Entity<ApplicationUser>()
            //  .HasOne(u => u.Users)
            //   .WithOne(user => user.ApplicationUser)
            //   .HasForeignKey<User>(user => user.ApplicationUserId);
            //modelBuilder.Entity<ApplicationUser>().ToTable("AspNetUsers"); // نام جدول مرتبط با ApplicationUser را تغییر می‌دهیم
            //modelBuilder.Entity<User>().ToTable("Users"); // نام جدول مرتبط با User را تغییر می‌دهیم

            //// تعریف رابطه بین ApplicationUser و User
            //modelBuilder.Entity<ApplicationUser>()
            //    .HasOne(u => u.User)
            //    .WithOne(user => user.ApplicationUser)
            //    .HasForeignKey<User>(user => user.ApplicationUserId);
            //The entity type 'IdentityUserToken<Guid>' requires a primary key to be defined.If you intended to use a keyless entity type, call 'HasNoKey' in 'OnModelCreating'.For more information on keyless entity types, see https://go.microsoft.com/fwlink/?linkid=2141943.




            var Applicationuser  = new ApplicationUser
                {
                    UserName = this.User_Code,
                    Users = new AuthTestUser.Entities.User()
                    {
                        User_ID = this.User_ID,
                        User_Code = this.User_Code,
                        User_Pass = this.User_Pass,
                        User_FullName = this.User_FullName,
                        User_Role = this.User_Role
                    }

                };
                var result =  _userManager.CreateAsync(Applicationuser, this.User_Pass);
                _userManager.AddToRoleAsync(Applicationuser, this.User_Role);
                https://stackoverflow.com/questions/52038054/web-api-core-returns-404-when-adding-authorize-attribute
                why when not authorize in web api bring bring back error 404 not error no authorize


-------------





                Responses
Curl

curl -X 'POST' \
  'http://localhost:8000/Auth/login' \
  -H 'accept: */*' \
  -H 'Content-Type: application/json' \
  -d '{
  "user_Pass": "1",
  "user_Code": "1111"
}'
Request URL
http://localhost:8000/Auth/login
Server response
Code	Details
500
Undocumented
Error: Internal Server Error

Response body
Download
System.InvalidOperationException: Unable to resolve service for type 'Microsoft.AspNetCore.Identity.UserManager`1[DomainClasses.Entities.ApplicationUser]' while attempting to activate 'Application.Controllers.AuthController'.
   at Microsoft.Extensions.DependencyInjection.ActivatorUtilities.GetService(IServiceProvider sp, Type type, Type requiredBy, Boolean isDefaultParameterRequired)
   at lambda_method103(Closure, IServiceProvider, Object[])
   at Microsoft.AspNetCore.Mvc.Controllers.ControllerFactoryProvider.<>c__DisplayClass6_0.<CreateControllerFactory>g__CreateController|0(ControllerContext controllerContext)
   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.Next(State& next, Scope& scope, Object& state, Boolean& isCompleted)
   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.InvokeInnerFilterAsync()
--- End of stack trace from previous location ---
   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.<InvokeFilterPipelineAsync>g__Awaited|20_0(ResourceInvoker invoker, Task lastTask, State next, Scope scope, Object state, Boolean isCompleted)
   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.<InvokeAsync>g__Logged|17_1(ResourceInvoker invoker)
   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.<InvokeAsync>g__Logged|17_1(ResourceInvoker invoker)
   at Microsoft.AspNetCore.Routing.EndpointMiddleware.<Invoke>g__AwaitRequestTask|6_0(Endpoint endpoint, Task requestTask, ILogger logger)
   at Swashbuckle.AspNetCore.SwaggerUI.SwaggerUIMiddleware.Invoke(HttpContext httpContext)
   at Swashbuckle.AspNetCore.Swagger.SwaggerMiddleware.Invoke(HttpContext httpContext, ISwaggerProvider swaggerProvider)
   at Microsoft.AspNetCore.Authorization.AuthorizationMiddleware.Invoke(HttpContext context)
   at Microsoft.AspNetCore.Authentication.AuthenticationMiddleware.Invoke(HttpContext context)
   at Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddlewareImpl.Invoke(HttpContext context)

HEADERS
=======
Accept: */*
Connection: keep-alive
Host: localhost:8000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36
Accept-Encoding: gzip, deflate, br
Accept-Language: en-US,en;q=0.9
Content-Type: application/json
Origin: http://localhost:8000
Referer: http://localhost:8000/swagger/index.html
Content-Length: 45
sec-ch-ua: "Google Chrome";v="117", "Not;A=Brand";v="8", "Chromium";v="117"
sec-ch-ua-mobile: ?0
sec-ch-ua-platform: "Windows"
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: cors
Sec-Fetch-Dest: empty
Response headers
 access-control-allow-origin: * 
 content-type: text/plain; charset=utf-8 
 date: Sat,14 Oct 2023 09:01:13 GMT 
 server: Kestrel 
 transfer-encoding: chunked -----------

 program web api 
 using Application.Classes;
using DataLayer.Classes;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.Extensions.Options;
using Microsoft.IdentityModel.Tokens;
using Microsoft.AspNetCore.HttpOverrides;
using System.Text;
using DomainClasses.Context;
using Microsoft.EntityFrameworkCore;
using DomainClasses.Entities;
using Microsoft.AspNetCore.Identity;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.

builder.Services.AddControllers();
// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
builder.Services.AddCors();

#region Jwt

//var JwtSettingSection = builder.Configuration.GetSection("JWTSettings");
//builder.Services.Configure<JWTSettings>(JwtSettingSection);

//var jwtsetting = JwtSettingSection.Get<JWTSettings>();
//var key = Encoding.ASCII.GetBytes(jwtsetting.Secret);

//builder.Services.AddAuthentication(a =>
//{
//    a.DefaultSignInScheme = JwtBearerDefaults.AuthenticationScheme;
//    a.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
//    a.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
//}).AddJwtBearer(option =>
//{
//    option.TokenValidationParameters = new TokenValidationParameters
//    {
//        IssuerSigningKey = new SymmetricSecurityKey(key),
//        ValidateIssuerSigningKey = true,
//        ValidIssuer = jwtsetting.Issure,
//        ValidateIssuer = true,
//        ValidAudience = jwtsetting.Audience,
//        ValidateAudience = true,
//        ValidateLifetime = true

//    };
//});

//builder.Services.AddDbContext<ApplicationDbContext>();


#endregion
var app = builder.Build();
app.UseForwardedHeaders(new ForwardedHeadersOptions
{
    ForwardedHeaders = ForwardedHeaders.XForwardedFor
});
// Configure the HTTP request pipeline.

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();

//app.UseAuthentication();
//app.UseAuthorization();

//using var scope = app.Services.CreateScope();
//var dbContext = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();
//dbContext.Database.Migrate();

app.MapControllers();
app.UseCors(x => x.AllowAnyOrigin().AllowAnyHeader().AllowAnyMethod());

app.Run();


program userlayer


using AuthTestUser.Entities;
using DomainClasses.Context;
using Microsoft.AspNetCore.Identity;
using Microsoft.EntityFrameworkCore;
using System;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.

builder.Services.AddControllersWithViews();
builder.Services.AddDbContext<ApplicationDbContext>();
builder.Services.AddCors();


builder.Services.AddIdentity<ApplicationUser, IdentityRole<Guid>>(
    options =>
    {

        options.Password.RequireLowercase = false;
        options.Password.RequireUppercase = false;
        options.Password.RequireDigit = false;
        options.Password.RequiredLength = 4;
        options.Password.RequireNonAlphanumeric = false;

    }
    )
.AddEntityFrameworkStores<ApplicationDbContext>();
var app = builder.Build();

// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
}

using var scope = app.Services.CreateScope();
var dbContext = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();
dbContext.Database.Migrate();



app.UseStaticFiles();
app.UseRouting();

app.UseAuthentication();
app.UseAuthorization();

app.MapControllerRoute(
    name: "default",
    pattern: "{controller}/{action=Index}/{id?}");

app.MapFallbackToFile("index.html");
app.UseCors(x => x.AllowAnyOrigin().AllowAnyHeader().AllowAnyMethod());

app.Run();
